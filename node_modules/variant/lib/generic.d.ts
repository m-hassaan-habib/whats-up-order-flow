import { Func, Identity } from './util';
import { Matrix, OutVariant, Property, RawVariant, TypeNames, VariantOf } from './variant';
declare type primitive = number | string | symbol | boolean;
declare type GenericMapping = {
    [key: string]: any;
};
declare type VGenericTuple<T extends ReadonlyArray<any>, Map extends GenericMapping> = {
    [P in keyof T]: Identity<Generify<T[P], Map>>;
};
declare type VGenericFunction<T, Map extends GenericMapping> = T extends (...args: infer TArgs) => infer TR ? (...anonArgs: VGenericTuple<TArgs, Map>) => Identity<Generify<TR, Map>> : T;
declare type VGenericObject<T, Map extends GenericMapping> = Identity<{
    [P in keyof T]: Generify<T[P], Map>;
}>;
export declare type Generify<T, Map extends GenericMapping> = T extends VGeneric<infer Label> ? Map[Label] : T extends ReadonlyArray<any> ? VGenericTuple<T, Map> : T extends Func ? VGenericFunction<T, Map> : T extends primitive ? T : T extends object ? VGenericObject<T, Map> : T;
declare type VGeneric<Label extends string> = {
    __gen: Label;
};
declare const gParamKey = "__gen";
export declare const GParam: import("./variant").VariantModuleFromList<import("./variant").VariantCreator<"A", () => {}, "__gen"> | import("./variant").VariantCreator<"B", () => {}, "__gen"> | import("./variant").VariantCreator<"C", () => {}, "__gen"> | import("./variant").VariantCreator<"D", () => {}, "__gen"> | import("./variant").VariantCreator<"E", () => {}, "__gen"> | import("./variant").VariantCreator<"F", () => {}, "__gen"> | import("./variant").VariantCreator<"G", () => {}, "__gen"> | import("./variant").VariantCreator<"H", () => {}, "__gen"> | import("./variant").VariantCreator<"I", () => {}, "__gen"> | import("./variant").VariantCreator<"J", () => {}, "__gen"> | import("./variant").VariantCreator<"K", () => {}, "__gen"> | import("./variant").VariantCreator<"L", () => {}, "__gen"> | import("./variant").VariantCreator<"M", () => {}, "__gen"> | import("./variant").VariantCreator<"N", () => {}, "__gen"> | import("./variant").VariantCreator<"O", () => {}, "__gen"> | import("./variant").VariantCreator<"P", () => {}, "__gen"> | import("./variant").VariantCreator<"Q", () => {}, "__gen"> | import("./variant").VariantCreator<"R", () => {}, "__gen"> | import("./variant").VariantCreator<"S", () => {}, "__gen"> | import("./variant").VariantCreator<"T", () => {}, "__gen"> | import("./variant").VariantCreator<"U", () => {}, "__gen"> | import("./variant").VariantCreator<"V", () => {}, "__gen"> | import("./variant").VariantCreator<"W", () => {}, "__gen"> | import("./variant").VariantCreator<"X", () => {}, "__gen"> | import("./variant").VariantCreator<"Y", () => {}, "__gen"> | import("./variant").VariantCreator<"Z", () => {}, "__gen">>;
export declare type GParam<T extends TypeNames<typeof GParam, typeof gParamKey> = undefined> = VariantOf<typeof GParam, T, typeof gParamKey>;
declare const Alpha: {
    A: {
        __gen: "A";
    };
    B: {
        __gen: "B";
    };
    C: {
        __gen: "C";
    };
    D: {
        __gen: "D";
    };
    E: {
        __gen: "E";
    };
    F: {
        __gen: "F";
    };
    G: {
        __gen: "G";
    };
    H: {
        __gen: "H";
    };
    I: {
        __gen: "I";
    };
    J: {
        __gen: "J";
    };
    K: {
        __gen: "K";
    };
    L: {
        __gen: "L";
    };
    M: {
        __gen: "M";
    };
    N: {
        __gen: "N";
    };
    O: {
        __gen: "O";
    };
    P: {
        __gen: "P";
    };
    Q: {
        __gen: "Q";
    };
    R: {
        __gen: "R";
    };
    S: {
        __gen: "S";
    };
    T: {
        __gen: "T";
    };
    U: {
        __gen: "U";
    };
    V: {
        __gen: "V";
    };
    W: {
        __gen: "W";
    };
    X: {
        __gen: "X";
    };
    Y: {
        __gen: "Y";
    };
    Z: {
        __gen: "Z";
    };
};
declare type Alpha = Matrix<typeof GParam, typeof gParamKey>;
export declare type GFunc<TFunc> = TFunc extends (...args: infer TArgs) => infer TR ? <T>(...args: VGenericTuple<TArgs, {
    [GP: string]: T;
}>) => Identity<Generify<TR, {
    [GP: string]: T;
}>> : TFunc;
export declare type GFunced<T> = {
    [P in keyof T]: GFunc<T[P]>;
};
export declare function gg<T extends RawVariant>(f: (alpha: Alpha) => T): readonly [Identity<GFunced<OutVariant<T>>>, Identity<OutVariant<T>>];
export declare const genericVariant: typeof gg;
declare type BaselineG<K extends string = 'type'> = {
    [key: string]: (...args: any[]) => Property<K, string>;
};
export declare type GSum<T extends BaselineG<K>, K extends string = 'type'> = ReturnType<T[keyof T]>;
export declare type GKeysOf<T extends BaselineG<K>, K extends string = 'type'> = ReturnType<T[keyof T]>[K];
export declare type GTypeNames<T extends BaselineG<K>, K extends string = 'type'> = GKeysOf<T, K> | undefined;
export declare type GVariantOf<T extends BaselineG, TType extends GTypeNames<T>, TypeReplacement extends {
    [GP: string]: any;
}> = TType extends undefined ? Identity<Generify<GSum<T>, TypeReplacement>> : TType extends GKeysOf<T> ? Generify<Extract<GSum<T>, Property<'type', TType>>, TypeReplacement> : Identity<Generify<GSum<T>, TypeReplacement>>;
export {};
//# sourceMappingURL=generic.d.ts.map