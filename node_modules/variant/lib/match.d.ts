import { Func } from './util';
import { TypeExt, UnionHandler, VariantsOfUnion, Property } from './variant';
/**
 * Built to describe an object with the same keys as a variant but instead of constructors
 * for those objects has functions that handle objects of that type.
 */
export declare type Handler<T, U = any> = {
    [P in keyof T]: (variant: T[P]) => U;
};
/**
 * Either the full handler or the partial set plus 'default'
 */
declare type WithDefault<T, U = any> = (Partial<T> & {
    default: (...args: Parameters<FuncsOnly<T>[keyof T]>) => U;
}) | T;
/**
 * Pick just the functions of an object.
 */
declare type FuncsOnly<T> = {
    [P in keyof T]: T[P] extends Func ? T[P] : never;
};
/**
 * The key used to indicate the default handler.
 */
export declare const DEFAULT_KEY = "default";
export declare type DEFAULT_KEY = typeof DEFAULT_KEY;
/**
 * Catch-all type to express type errors.
 */
export interface VariantError<T> {
    __error: never;
    __message: T;
}
/**
 * Prevents 'overflow' in a literal.
 *
 * @todo this may be unnecessary if you use that 'splay partial' trick.
 */
export declare type Limited<T, U> = Exclude<keyof T, U> extends never ? T : VariantError<['Expected keys of handler', keyof T, 'to be limited to possible keys', U]>;
/**
 * Strip undefined from a union of types.
 */
export declare type Defined<T> = T extends undefined ? never : T;
/**
 * Match a variant against its possible options and do some processing
 * based on the type of variant received.
 * @param obj the variant in question
 * @param handler an object whose keys are the type names of the variant's type and values are handler functions for each option.
 * @returns The union of the return types of the various branches of the handler object
 */
export declare function match<T extends Property<'type', string>, H extends WithDefault<Handler<VariantsOfUnion<T>>>>(obj: T, handler: H & Limited<H, T['type'] | DEFAULT_KEY>): ReturnType<Limit<FuncsOnly<H>, T['type'] | DEFAULT_KEY>[keyof H]>;
/**
 * Match a variant against its possible options and do some processing
 * based on the type of variant received.
 * @param obj the variant in question
 * @param handler an object whose keys are the type names of the variant's type and values are handler functions for each option.
 * @param {string?} typeKey override the property to inspect. By default, 'type'.
 * @returns The union of the return types of the various branches of the handler object
 */
export declare function match<T extends Property<K, string>, H extends WithDefault<Handler<VariantsOfUnion<T, K>>>, K extends string = 'type'>(obj: T, handler: H & Limited<H, T[K] | DEFAULT_KEY>, typeKey?: K): ReturnType<Limit<FuncsOnly<H>, T[K] | DEFAULT_KEY>[keyof H]>;
/**
 * Match a variant against it's some of its possible options and do some
 * processing based on the type of variant received. Finally, take the remaining
 * possibilities and handle them in a function.
 *
 * The input to the 'or' clause is well-typed.
 *
 * @param obj the variant in question
 * @param handler an object whose keys are the type names of the variant's type and values are handler functions for each option.
 * @param {string?} typeKey override the property to inspect. By default, 'type'.
 * @returns {The union of the return types of the various branches of the handler object}
 */
export declare function match<T extends Property<K, string>, H extends Partial<Handler<VariantsOfUnion<T, K>>>, E extends (rest: Exclude<T, TypeExt<K, keyof H>>) => any, K extends string = 'type'>(obj: T, handler: H, _else: E, typeKey?: K): ReturnType<Defined<FuncsOnly<H>[keyof H]>> | ReturnType<E>;
/**
 * Match a literal against some of its possible options and do some processing based
 * on the type of literal received. Works well with strEnum
 * @param literal
 * @param handler
 */
export declare function matchLiteral<T extends string, H extends UnionHandler<T>>(literal: T, handler: H): ReturnType<H[T]>;
declare type Limit<T, Keys extends string> = {
    [P in keyof T]: P extends Keys ? T[P] : never;
};
export declare const noop: (..._: any[]) => void;
/**
 * Extract the payload element from the object and return it.
 *
 * Unstable API.
 *
 * Shorthand for
 *
 * ```ts
 * match(object, {
 *     ...
 *     case: unpack,
 *     ...
 * })
 * ```
 * @param x
 */
export declare const unpack: <T>(x: {
    payload: T;
}) => T;
/**
 * Ignore the matched object and return a specific value.
 *
 * Unstable API.
 *
 * ```ts
 * match(object, {
 *     ...
 *     case: just(true),
 *     ...
 * })
 * ```
 * @param x
 */
export declare const just: <T>(x: T) => () => T;
export {};
//# sourceMappingURL=match.d.ts.map