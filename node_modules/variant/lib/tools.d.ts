import { Property, VariantCreator } from "./variant";
import { ExtractOfUnion, Func } from "./util";
/**
 * Enforce exhaustion of a union type by using this in the default case.
 * @param x
 * @param options
 */
export declare function exhaust(x: never, options?: {
    key: string;
    throw: boolean;
}): void;
/**
 * Handles boilerplate with the most common function definiton.
 * Also provides a clean way of describing things in a record-like
 * way.
 *
 * const ItemOne = variant('ITEM_ONE', fields<{
 *     id: number;
 *     name: string;
 * }>());
 *
 * You can also use .set() to assign some elements of an interface. For example:
 *
 * interface Audited<T> extends T {
 *     createdDate: number; // millis
 * }
 *
 * @param defaults set some default values for the object. Note this does not remove
 */
export declare function fields<T>(defaults?: Partial<T>): (input: T) => T;
/**
 * Take a single variable of type T and store as 'payload'
 */
export declare function payload<T>(_example?: T): (payload: T) => {
    payload: T;
};
export declare function property<K extends string = 'payload'>(key: K): <T>() => (payload: T) => K extends keyof infer KLiteral ? Property<keyof KLiteral & string, T> : never;
export declare function data<T>(x: T): (override?: T | undefined) => T & {};
/**
 * Meant to be used inside of a `match`
 * @param x
 */
export declare function constant<T>(x: T): () => T;
declare type FlattenToTypeStr<T extends (string | VariantCreator<string, Func, K>), K extends string = 'type'> = T extends VariantCreator<infer R, Func, K> ? R : T extends string ? T : never;
/**
 * Curried isType, useful for `.filter` or rxjs
 * @param type
 */
export declare function isType<T extends (string | VariantCreator<string, Func, K>), K extends string = 'type'>(type: T): <O extends Property<K, string>>(o: O) => o is ExtractOfUnion<O, FlattenToTypeStr<T, K>, K>;
/**
 * Check if an object is of a given type. The type here
 * may be a string or a variant constructor (i.e. `Animal.dog`).
 *
 * If the object being analyzed is typed as a union, typing
 * a string will autocomplete the property names and providing
 * a function will be restricted to the set of variant creators
 * for those potential types.
 * @param instance some JS object
 * @param type a string for the type, or the constructor for that variant
 * @param key optional discriminant key override. 'type' by default.
 */
export declare function isType<O extends Property<K, string>, T extends (O[K] | VariantCreator<O[K], Func, K>), K extends string = 'type'>(instance: O | {} | null | undefined, type: T, key?: K): instance is ExtractOfUnion<O, T extends VariantCreator<infer R, Func, K> ? R : T extends string ? T : never, K>;
export {};
//# sourceMappingURL=tools.d.ts.map