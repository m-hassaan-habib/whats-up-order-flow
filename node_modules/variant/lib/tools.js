"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isType = exports.constant = exports.data = exports.property = exports.payload = exports.fields = exports.exhaust = void 0;
/**
 * Enforce exhaustion of a union type by using this in the default case.
 * @param x
 * @param options
 */
function exhaust(x, options = { key: 'type', throw: false }) {
    // Should never be called. If it ever *does* happen to be called it'll dump the type string.
    // I find this to be a reasonable balance between avoiding data in the logs and providing
    // useful debugging info.
    const msg = `Switch does not handle all cases. Failed case:${x[options.key]}`;
    if (options.throw) {
        throw new Error(msg);
    }
}
exports.exhaust = exhaust;
/**
 * Handles boilerplate with the most common function definiton.
 * Also provides a clean way of describing things in a record-like
 * way.
 *
 * const ItemOne = variant('ITEM_ONE', fields<{
 *     id: number;
 *     name: string;
 * }>());
 *
 * You can also use .set() to assign some elements of an interface. For example:
 *
 * interface Audited<T> extends T {
 *     createdDate: number; // millis
 * }
 *
 * @param defaults set some default values for the object. Note this does not remove
 */
function fields(defaults = {}) {
    return (input) => (Object.assign(Object.assign({}, defaults), input));
}
exports.fields = fields;
/**
 * Take a single variable of type T and store as 'payload'
 */
function payload(_example) {
    return (payload) => ({ payload });
}
exports.payload = payload;
function property(key) {
    return () => (payload) => ({ [key]: payload });
}
exports.property = property;
function data(x) {
    return (override) => (Object.assign(Object.assign({}, x), (override != undefined && override)));
}
exports.data = data;
/**
 * Meant to be used inside of a `match`
 * @param x
 */
function constant(x) {
    return () => x;
}
exports.constant = constant;
function isType(instanceOrType, typeOrKey, key) {
    if (instanceOrType != undefined) {
        if (typeof instanceOrType === 'function' || typeof instanceOrType === 'string') {
            const typeArg = instanceOrType;
            const typeStr = typeof typeArg === 'string' ? typeArg : typeArg.type;
            return (o) => isType(o, typeStr);
        }
        else {
            const instance = instanceOrType;
            const type = typeOrKey;
            const typeStr = typeof type === 'string' ? type : type.type;
            return instance != undefined && instance[key !== null && key !== void 0 ? key : 'type'] === typeStr;
        }
    }
    else {
        return false;
    }
}
exports.isType = isType;
//# sourceMappingURL=tools.js.map